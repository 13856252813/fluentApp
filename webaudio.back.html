<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    html,body{
        width: 100%;
        height: 100%;
    }
    input{
        position: absolute;
        left: 0px;
        top: 0px;
    }
    canvas{
        width:100%;
        height: 100%;
    }
</style>
<body>
<audio src="./server/public/btr.mp3" controls style="margin-top: 30px;" id="audio"></audio>
<input type="file" id="file">
<canvas id="canvas"></canvas>
</body>
<script>
    var audioContext=new window.AudioContext();
    var file = document.getElementById('file');
    file.onchange = function (e) {
        var file = e.target.files[0];
        var reader = new FileReader();
        reader.readAsArrayBuffer(file);
        console.log(reader)
        reader.onload = function (e) {
            var fileRes = e.target.result;
            audioContext.decodeAudioData(fileRes, function (buffer) {
                var audioBufferSouceNode = audioContext.createBufferSource();
                var analyser = audioContext.createAnalyser();
                audioBufferSouceNode.connect(analyser);
                analyser.connect(audioContext.destination);
                audioBufferSouceNode.buffer = buffer;
                audioBufferSouceNode.start(0);
                var stop = 0;
                function con() {
                    var array = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(array);
                    draw(array);
                    requestAnimationFrame(con);
                }
                requestAnimationFrame(con)
            })
        }
    };

    var myAudio = document.querySelector('audio');
    myAudio.crossOrigin = 'anonymous';
    myAudio.src='https://fourthof5assets.s3-eu-west-1.amazonaws.com/heng-feeling-good.mp3';
    var source = audioContext.createMediaElementSource(myAudio);
    var analyser = audioContext.createAnalyser();
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    function con() {
        var array = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(array);
        draw(array);
        requestAnimationFrame(con);
    }
    requestAnimationFrame(con)


    var canvas = document.getElementById('canvas');
    var width = canvas.offsetWidth;
    var height = canvas.offsetHeight;
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    var baseY = height / 2;

    function getDot(start, end) {
        var s2eCenter = {x: Math.floor(start.x + (end.x - start.x) / 2), y: Math.floor(start.y + (end.y - start.y) / 2)};
        return s2eCenter;
    }

    function draw(array) {
        ctx.clearRect(0,0,width, height);
        // var s = 0;
        // var step = width / array.length * 1;
        // array.map((data, k) => {
        //     if(s == 0) {
        //         ctx.fillStyle = 'rgba(240,143,143,0.8)';
        //         //二次贝塞尔曲线
        //         var curDot = {x: k*step, y: baseY - data};
        //         var nextDot = {x: (k + 100) * step, y: baseY - array[k + 100]};
        //         var c2nCenter = getDot(curDot, nextDot);
        //         ctx.quadraticCurveTo(curDot.x,curDot.y,c2nCenter.x,c2nCenter.y);
        //         s = 100;
        //     }else{
        //         s--;
        //     }
        // });
        var s = 100;
        var CGArr = [];
        let CGArr2 = [];
        array.map((data, k) => {
            if(s == 100) {
                CGArr.push({
                    x: ((width / 1.6) / array.length) * k + 300,
                    y: baseY - data,
                });
                CGArr2.push({
                    x: ((width / 1.6) / array.length) * k + 300,
                    y: (baseY + data * 0.4 - 50 ) ,
                });
                s = 0;
            }else {
                s ++;
            }
        });
        var lastX = CGArr[CGArr.length - 1].x;
        var lastX2 = CGArr2[CGArr2.length - 1].x;
        for(var i = 1; i < 5; i ++) {
            CGArr.unshift({x: -100 * i + 300, y: baseY - (array[300 + i * 20]) / 1.6});
            CGArr2.unshift({x: -100 * i + 300, y: baseY - (array[350 + i * 20]) / 1.2})
        }
        for(var i = 0; i < 8; i++ ) {
            // CGArr.push({x: lastX + (i * 100), y: baseY - (array[400 + i * 20]) / 1.6});
            // CGArr2.push({x: lastX2 + (i * 100), y: baseY - (array[450 + i * 20]) / 1.3});
        }
        ctx.beginPath();
        ctx.fillStyle = 'rgba(240,143,143,0.5)';
        ctx.moveTo(CGArr2[0].x, CGArr2[0].y);
        for(var i = 1; i < CGArr2.length - 2; i ++) {
            var p0 = CGArr2[i - 1];
            var p1 = CGArr2[i];
            var p2 = CGArr2[i + 1];
            var p3 = CGArr2[i + 2];

            for(var j = 0; j < 100; j ++) {
                var t = j * (1.0 / 100);
                var tt = t * t;
                var ttt = tt * t;
                var CGPoint ={};
                CGPoint.x = 0.5 * (2*p1.x+(p2.x-p0.x)*t + (2*p0.x-5*p1.x+4*p2.x-p3.x)*tt + (3*p1.x-p0.x-3*p2.x+p3.x)*ttt);
                CGPoint.y = 0.5 * (2*p1.y+(p2.y-p0.y)*t + (2*p0.y-5*p1.y+4*p2.y-p3.y)*tt + (3*p1.y-p0.y-3*p2.y+p3.y)*ttt);
                ctx.lineTo(CGPoint.x, CGPoint.y);
            }
            ctx.lineTo(p2.x, p2.y);
        }
        ctx.lineTo(CGArr2[CGArr2.length - 1].x, CGArr2[CGArr2.length - 1].y);
        ctx.lineTo(width, baseY);
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = 'rgba(240,143,143,0.9)';
        ctx.moveTo(CGArr[0].x, CGArr[0].y);
        for(var i = 1; i < CGArr.length - 2; i ++) {
            var p0 = CGArr[i - 1];
            var p1 = CGArr[i];
            var p2 = CGArr[i + 1];
            var p3 = CGArr[i + 2];

            for(var j = 0; j < 100; j ++) {
                var t = j * (1.0 / 100);
                var tt = t * t;
                var ttt = tt * t;
                var CGPoint ={};
                CGPoint.x = 0.5 * (2*p1.x+(p2.x-p0.x)*t + (2*p0.x-5*p1.x+4*p2.x-p3.x)*tt + (3*p1.x-p0.x-3*p2.x+p3.x)*ttt);
                CGPoint.y = 0.5 * (2*p1.y+(p2.y-p0.y)*t + (2*p0.y-5*p1.y+4*p2.y-p3.y)*tt + (3*p1.y-p0.y-3*p2.y+p3.y)*ttt);
                ctx.lineTo(CGPoint.x, CGPoint.y);
            }
            ctx.lineTo(p2.x, p2.y);
        }
        ctx.lineTo(CGArr[CGArr.length - 1].x, CGArr[CGArr.length - 1].y);
        ctx.lineTo(width, baseY);
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.fill();
    }

</script>
</html>